{
  "meta": {
    "title": "Sandra IA - Mega Collection de Prompts CLAUDE CODE Style",
    "version": "1.0",
    "author": "Claude Sonnet 4 - Code Assistant",
    "description": "Colecci√≥n masiva de prompts de nivel profesional para entrenamiento de Sandra IA",
    "categories": ["development", "architecture", "ui-ux", "api", "devops", "ai", "business", "security"],
    "total_prompts": 150,
    "created": "2024-12-15",
    "format": "JSONL compatible"
  },
  "prompts": [
    {
      "id": 1,
      "category": "development",
      "subcategory": "frontend",
      "difficulty": "expert",
      "title": "React TypeScript Booking System",
      "prompt": "Act√∫a como un desarrollador senior React con 10+ a√±os de experiencia. Crea un sistema completo de reservas para alojamiento vacacional usando React 18 + TypeScript + Vite. Requisitos espec√≠ficos:\n\nüìã FUNCIONALIDADES CORE:\n- Calendario interactivo con react-datepicker y validaci√≥n de disponibilidad\n- Formulario multi-step con React Hook Form + Zod validation\n- C√°lculo din√°mico de precios con descuentos, tasas y temporadas\n- Integraci√≥n de pagos con Stripe Elements v2\n- Sistema de reviews con rating visual\n- Chat en tiempo real con Socket.io\n- Gesti√≥n de estados con Zustand\n\nüé® UI/UX REQUIREMENTS:\n- Design system con Tailwind CSS + HeadlessUI\n- Responsive design (mobile-first)\n- Dark/Light theme toggle\n- Animaciones con Framer Motion\n- Loading states y error boundaries\n- Accessibility WCAG 2.1 AA\n\n‚ö° PERFORMANCE:\n- Code splitting por rutas\n- Lazy loading de componentes\n- Image optimization con next/image\n- PWA con service worker\n- Core Web Vitals < 2.5s LCP\n\nüîß ARQUITECTURA:\n- Feature-based folder structure\n- Custom hooks para l√≥gica de negocio\n- Context providers para estado global\n- Error handling robusto\n- TypeScript strict mode\n- Unit tests con Vitest + React Testing Library\n\nüì¶ DELIVERABLES:\n1. Estructura completa del proyecto\n2. Componentes principales con propTypes\n3. Hooks personalizados\n4. Configuraci√≥n de build\n5. Documentaci√≥n t√©cnica\n6. Tests unitarios\n\nEscribe c√≥digo production-ready con best practices y comentarios explicativos.",
      "tags": ["react", "typescript", "booking", "stripe", "frontend", "professional"],
      "complexity": 9,
      "estimated_time": "40-60 hours",
      "use_cases": ["vacation_rental", "hotel_booking", "appointment_system"]
    },
    {
      "id": 2,
      "category": "development",
      "subcategory": "backend",
      "difficulty": "expert",
      "title": "Node.js Microservices Architecture",
      "prompt": "Como arquitecto de software senior, dise√±a y desarrolla una arquitectura completa de microservicios para una plataforma de alquiler vacacional escalable a 1M+ usuarios.\n\nüèóÔ∏è ARQUITECTURA GENERAL:\n- API Gateway con rate limiting y auth\n- Service Discovery con Consul\n- Message Broker con Redis + RabbitMQ\n- Database per service pattern\n- Event Sourcing para audit trail\n- CQRS para read/write separation\n\nüîß MICROSERVICIOS CORE:\n1. **User Service** (Node.js + Express + PostgreSQL)\n   - Authentication JWT + refresh tokens\n   - User profiles y preferences\n   - Social login (Google, Facebook, Apple)\n   - Email verification y password reset\n\n2. **Property Service** (Node.js + Fastify + MongoDB)\n   - CRUD propiedades con geolocation\n   - Image upload con AWS S3 + CloudFront\n   - Search con Elasticsearch\n   - Pricing rules engine\n\n3. **Booking Service** (Node.js + Express + PostgreSQL)\n   - Reservation logic con distributed locks\n   - Calendar management\n   - Payment processing con Stripe\n   - Cancellation policies\n\n4. **Notification Service** (Node.js + WebSockets + Redis)\n   - Email templates con SendGrid\n   - Push notifications\n   - SMS con Twilio\n   - Real-time messaging\n\n5. **Analytics Service** (Node.js + ClickHouse)\n   - Event tracking\n   - Revenue analytics\n   - User behavior analysis\n   - Custom dashboards\n\nüìä INFRAESTRUCTURA:\n- Docker containers + Kubernetes\n- CI/CD con GitHub Actions\n- Monitoring con Prometheus + Grafana\n- Logging centralizado con ELK Stack\n- Secrets management con Vault\n- Load balancing con NGINX\n\nüîí SEGURIDAD:\n- OAuth 2.0 + OpenID Connect\n- API rate limiting\n- Input validation con Joi\n- SQL injection prevention\n- CORS configuration\n- Helmet.js security headers\n\nüìã DELIVERABLES:\n1. Diagrama de arquitectura completo\n2. C√≥digo de cada microservicio\n3. Docker compose para desarrollo\n4. Kubernetes manifests\n5. API documentation con Swagger\n6. Monitoring y alerting setup\n7. Security checklist\n8. Performance benchmarks\n\nIncluye c√≥digo production-ready con error handling, logging, testing y documentaci√≥n completa.",
      "tags": ["nodejs", "microservices", "kubernetes", "architecture", "scalability"],
      "complexity": 10,
      "estimated_time": "80-120 hours",
      "use_cases": ["saas_platform", "marketplace", "enterprise_system"]
    },
    {
      "id": 3,
      "category": "ui-ux",
      "subcategory": "design-system",
      "difficulty": "expert",
      "title": "Enterprise Design System Creation",
      "prompt": "Como Lead UX/UI Designer con experiencia en design systems empresariales, crea un design system completo y escalable para una plataforma de alquiler vacacional que funcione en web, m√≥vil y tablet.\n\nüé® FUNDAMENTOS VISUALES:\n\n**Color System:**\n- Primary palette con 9 variantes (50-900)\n- Secondary y accent colors\n- Semantic colors (success, warning, error, info)\n- Neutral grays con proper contrast ratios\n- Dark mode variants\n- Accessibility compliance WCAG 2.1 AA\n\n**Typography Scale:**\n- Font families (heading, body, monospace)\n- Type scale modular (1.125 ratio)\n- Line heights optimizados para legibilidad\n- Font weights y styles\n- Responsive typography\n\n**Spacing System:**\n- 8pt grid system\n- Spacing tokens (4, 8, 12, 16, 24, 32, 48, 64, 96px)\n- Component-specific spacing rules\n- Layout grid (12-column responsive)\n\n**Iconography:**\n- Icon library con 200+ icons\n- Consistent style (outline, filled, duotone)\n- Multiple sizes (16, 20, 24, 32, 48px)\n- SVG optimization\n- Icon usage guidelines\n\nüß© COMPONENT LIBRARY:\n\n**Atoms:**\n- Button (primary, secondary, ghost, danger)\n- Input fields (text, email, password, search)\n- Checkbox y radio buttons\n- Switch toggle\n- Avatar (user, property)\n- Badge y labels\n- Dividers\n- Loading spinners\n\n**Molecules:**\n- Search bar con filters\n- Card components (property, user, booking)\n- Form groups\n- Navigation breadcrumbs\n- Pagination\n- Date picker\n- Star rating\n- Price display\n\n**Organisms:**\n- Header navigation\n- Property listing grid\n- Booking form\n- User dashboard\n- Filter sidebar\n- Photo gallery\n- Review section\n- Chat interface\n\n**Templates:**\n- Homepage layout\n- Property detail page\n- Search results\n- User profile\n- Booking flow\n- Dashboard layouts\n\nüì± RESPONSIVE BEHAVIOR:\n- Breakpoints (mobile: 320px, tablet: 768px, desktop: 1024px, xl: 1440px)\n- Component adaptations por screen size\n- Touch targets m√≠nimos 44px\n- Mobile-first approach\n- Progressive enhancement\n\n‚ôø ACCESSIBILITY:\n- Color contrast ratios\n- Focus states visibles\n- Screen reader optimization\n- Keyboard navigation\n- ARIA labels y landmarks\n- Motion preferences\n\nüìã DELIVERABLES:\n1. Design tokens en JSON/CSS custom properties\n2. Figma component library completa\n3. Storybook con todos los componentes\n4. Documentation site\n5. Code snippets para developers\n6. Accessibility checklist\n7. Usage guidelines\n8. Migration guide\n9. Sketch/Adobe XD versions\n10. Mobile app specifications\n\nüîß IMPLEMENTACI√ìN:\n- Styled-components/Emotion setup\n- CSS-in-JS theme provider\n- Component props API\n- TypeScript definitions\n- Unit tests para componentes\n- Visual regression tests\n\nIncluye ejemplos reales de uso, best practices y governance para mantener consistencia en equipos grandes.",
      "tags": ["design-system", "figma", "accessibility", "components", "tokens"],
      "complexity": 9,
      "estimated_time": "60-80 hours",
      "use_cases": ["enterprise_platform", "multi_product", "design_team"]
    },
    {
      "id": 4,
      "category": "architecture",
      "subcategory": "cloud",
      "difficulty": "expert",
      "title": "AWS Serverless Architecture",
      "prompt": "Como Cloud Solutions Architect AWS Certified, dise√±a una arquitectura serverless completa y cost-optimized para una startup de alquiler vacacional que proyecta 100K reservas mensuales y necesita escalar globalmente.\n\n‚òÅÔ∏è ARQUITECTURA SERVERLESS:\n\n**API Layer:**\n- API Gateway con custom authorizers\n- Lambda functions (Node.js 18)\n- Request/response transformations\n- Throttling y rate limiting\n- CORS configuration\n- Custom domain con Route 53\n\n**Authentication & Authorization:**\n- Cognito User Pools\n- Identity Pools para guest access\n- Social providers (Google, Facebook, Apple)\n- MFA con SMS/TOTP\n- Custom attributes\n- Pre/post authentication triggers\n\n**Data Layer:**\n- DynamoDB con GSI optimizados\n- RDS Aurora Serverless para relational data\n- S3 para file storage\n- ElastiCache para caching\n- DocumentDB para search data\n- Timestream para analytics\n\n**Event Processing:**\n- EventBridge para event routing\n- SQS/SNS para messaging\n- Step Functions para workflows\n- Lambda triggers\n- Dead letter queues\n- Event replay capabilities\n\n**Frontend & CDN:**\n- CloudFront distribution\n- S3 static hosting\n- Lambda@Edge functions\n- Origin request/response policies\n- Caching strategies\n- Image optimization\n\n**Monitoring & Observability:**\n- CloudWatch dashboards\n- X-Ray distributed tracing\n- CloudTrail audit logs\n- Custom metrics y alarms\n- SNS notifications\n- Cost monitoring\n\nüèóÔ∏è SPECIFIC SERVICES DESIGN:\n\n**User Management Service:**\n```\nLambda Functions:\n- createUser (Cognito integration)\n- updateProfile (DynamoDB)\n- getUserProfile (with caching)\n- deleteUser (GDPR compliance)\n\nDatabase Design:\n- Users table (DynamoDB)\n- UserPreferences (JSON document)\n- UserSessions (TTL enabled)\n```\n\n**Property Management Service:**\n```\nLambda Functions:\n- createProperty (S3 image upload)\n- searchProperties (OpenSearch)\n- getPropertyDetails (cached)\n- updateAvailability (calendar sync)\n\nDatabase Design:\n- Properties table (DynamoDB)\n- PropertyImages (S3 references)\n- Availability calendar (sparse index)\n- Reviews aggregation\n```\n\n**Booking Engine:**\n```\nStep Functions Workflow:\n1. Validate availability\n2. Calculate pricing\n3. Process payment (Stripe)\n4. Create booking record\n5. Send confirmations\n6. Update calendar\n\nLambda Functions:\n- checkAvailability\n- calculatePrice\n- processPayment\n- createBooking\n- sendNotifications\n```\n\n**Notification System:**\n```\nEventBridge Rules:\n- Booking created ‚Üí Email + SMS\n- Payment failed ‚Üí Retry logic\n- Check-in reminder ‚Üí Push notification\n\nSNS Topics:\n- EmailNotifications\n- SMSNotifications\n- PushNotifications\n```\n\nüí∞ COST OPTIMIZATION:\n- Lambda provisioned concurrency para hot functions\n- DynamoDB on-demand vs provisioned\n- S3 intelligent tiering\n- CloudFront caching optimization\n- Reserved capacity para predictable workloads\n- Spot instances para batch processing\n\nüîí SECURITY:\n- IAM least privilege\n- VPC endpoints para private communication\n- Secrets Manager para API keys\n- WAF rules para API protection\n- Encryption in transit y at rest\n- Security groups y NACLs\n\nüìä SCALABILITY & PERFORMANCE:\n- Auto-scaling policies\n- Database connection pooling\n- Caching layers (multiple levels)\n- Geographic distribution\n- Cold start optimization\n- Performance monitoring\n\nüåç MULTI-REGION SETUP:\n- Primary region: US-East-1\n- Secondary region: EU-West-1\n- Cross-region replication\n- Route 53 health checks\n- Disaster recovery procedures\n\nüìã DELIVERABLES:\n1. Complete CloudFormation/CDK templates\n2. Architecture diagrams (AWS Architecture Icons)\n3. Cost estimation spreadsheet\n4. Performance benchmarks\n5. Security assessment\n6. Deployment pipeline (CodePipeline)\n7. Monitoring runbooks\n8. Disaster recovery plan\n9. Migration strategy\n10. Operations manual\n\nüöÄ DEPLOYMENT STRATEGY:\n- Blue/Green deployments\n- Canary releases\n- Feature flags\n- Rollback procedures\n- Environment promotion\n- Infrastructure as Code\n\nIncluye c√≥digo de ejemplo, best practices AWS Well-Architected Framework y m√©tricas de performance esperadas.",
      "tags": ["aws", "serverless", "lambda", "architecture", "scalability", "cost-optimization"],
      "complexity": 10,
      "estimated_time": "100-150 hours",
      "use_cases": ["serverless_platform", "high_scale", "cost_sensitive"]
    },
    {
      "id": 5,
      "category": "api",
      "subcategory": "graphql",
      "difficulty": "expert",
      "title": "GraphQL API with Advanced Features",
      "prompt": "Como Senior Backend Engineer especializado en GraphQL, desarrolla una API GraphQL completa y optimizada para una plataforma de marketplace de alojamientos que maneje consultas complejas de manera eficiente.\n\nüîß TECH STACK:\n- Apollo Server 4 con Express\n- TypeScript strict mode\n- Prisma ORM con PostgreSQL\n- Redis para caching\n- DataLoader para N+1 optimization\n- GraphQL Code Generator\n- Jest para testing\n\nüìä SCHEMA DESIGN:\n\n```graphql\ntype Query {\n  # Property queries con filtering avanzado\n  properties(\n    filter: PropertyFilter\n    sort: PropertySort\n    pagination: PaginationInput\n  ): PropertyConnection!\n  \n  property(id: ID!): Property\n  \n  # Search con faceted filtering\n  searchProperties(\n    query: String!\n    filters: SearchFilters\n    location: LocationInput\n  ): SearchResult!\n  \n  # User queries\n  me: User\n  user(id: ID!): User\n  \n  # Booking queries\n  bookings(status: BookingStatus): [Booking!]!\n  booking(id: ID!): Booking\n  \n  # Analytics queries\n  propertyAnalytics(propertyId: ID!, period: AnalyticsPeriod!): Analytics!\n}\n\ntype Mutation {\n  # Authentication\n  login(input: LoginInput!): AuthPayload!\n  register(input: RegisterInput!): AuthPayload!\n  refreshToken(refreshToken: String!): AuthPayload!\n  \n  # Property management\n  createProperty(input: CreatePropertyInput!): Property!\n  updateProperty(id: ID!, input: UpdatePropertyInput!): Property!\n  deleteProperty(id: ID!): Boolean!\n  \n  # Booking mutations\n  createBooking(input: CreateBookingInput!): BookingResult!\n  cancelBooking(id: ID!, reason: String): Booking!\n  \n  # Review system\n  createReview(input: CreateReviewInput!): Review!\n  \n  # File uploads\n  uploadPropertyImages(propertyId: ID!, files: [Upload!]!): [PropertyImage!]!\n}\n\ntype Subscription {\n  # Real-time booking updates\n  bookingUpdated(propertyId: ID!): Booking!\n  \n  # Chat messages\n  messageAdded(conversationId: ID!): Message!\n  \n  # Price changes\n  priceUpdated(propertyId: ID!): Property!\n}\n```\n\nüèóÔ∏è RESOLVERS ARCHITECTURE:\n\n**Property Resolvers:**\n```typescript\nconst PropertyResolvers = {\n  Query: {\n    properties: async (parent, args, context) => {\n      const { filter, sort, pagination } = args;\n      \n      // Implement complex filtering logic\n      const whereClause = buildWhereClause(filter);\n      const orderBy = buildOrderBy(sort);\n      \n      // Use DataLoader for efficient batching\n      return context.dataSources.propertyAPI.findMany({\n        where: whereClause,\n        orderBy,\n        ...pagination\n      });\n    },\n    \n    searchProperties: async (parent, args, context) => {\n      // Integrate with Elasticsearch for full-text search\n      return context.dataSources.searchAPI.search(args);\n    }\n  },\n  \n  Property: {\n    // Efficient nested resolvers\n    owner: (property, args, context) => \n      context.loaders.userLoader.load(property.ownerId),\n    \n    reviews: (property, args, context) => \n      context.loaders.reviewsByPropertyLoader.load(property.id),\n    \n    availability: (property, args, context) => \n      context.dataSources.calendarAPI.getAvailability(property.id),\n    \n    averageRating: (property, args, context) => \n      context.loaders.averageRatingLoader.load(property.id)\n  }\n};\n```\n\n**DataLoaders para N+1 Optimization:**\n```typescript\nclass DataLoaders {\n  userLoader = new DataLoader(async (userIds: string[]) => {\n    const users = await prisma.user.findMany({\n      where: { id: { in: userIds } }\n    });\n    return userIds.map(id => users.find(user => user.id === id));\n  });\n  \n  reviewsByPropertyLoader = new DataLoader(async (propertyIds: string[]) => {\n    const reviews = await prisma.review.findMany({\n      where: { propertyId: { in: propertyIds } },\n      include: { user: true }\n    });\n    \n    return propertyIds.map(id => \n      reviews.filter(review => review.propertyId === id)\n    );\n  });\n  \n  averageRatingLoader = new DataLoader(async (propertyIds: string[]) => {\n    const ratings = await prisma.review.groupBy({\n      by: ['propertyId'],\n      where: { propertyId: { in: propertyIds } },\n      _avg: { rating: true }\n    });\n    \n    return propertyIds.map(id => {\n      const rating = ratings.find(r => r.propertyId === id);\n      return rating?._avg.rating || 0;\n    });\n  });\n}\n```\n\n‚ö° PERFORMANCE OPTIMIZATIONS:\n\n**Query Complexity Analysis:**\n```typescript\nimport { createComplexityLimitRule } from 'graphql-query-complexity';\n\nconst server = new ApolloServer({\n  typeDefs,\n  resolvers,\n  plugins: [\n    ApolloServerPluginQueryComplexity({\n      maximumComplexity: 1000,\n      variables: {},\n      introspection: true,\n      scalarCost: 1,\n      objectCost: 1,\n      listFactor: 10,\n      estimators: [\n        fieldExtensionsEstimator(),\n        simpleEstimator({ defaultComplexity: 1 })\n      ]\n    })\n  ]\n});\n```\n\n**Redis Caching Strategy:**\n```typescript\nclass CacheService {\n  private redis = new Redis(process.env.REDIS_URL);\n  \n  async cacheResolver(key: string, resolver: () => Promise<any>, ttl = 300) {\n    const cached = await this.redis.get(key);\n    if (cached) {\n      return JSON.parse(cached);\n    }\n    \n    const result = await resolver();\n    await this.redis.setex(key, ttl, JSON.stringify(result));\n    return result;\n  }\n  \n  async invalidatePattern(pattern: string) {\n    const keys = await this.redis.keys(pattern);\n    if (keys.length > 0) {\n      await this.redis.del(...keys);\n    }\n  }\n}\n```\n\nüîí SECURITY FEATURES:\n\n**Authentication & Authorization:**\n```typescript\nconst authDirective = {\n  AUTH: (next, source, args, context) => {\n    if (!context.user) {\n      throw new ForbiddenError('Authentication required');\n    }\n    return next();\n  },\n  \n  ROLE: (next, source, args, context, info) => {\n    const requiredRole = info.fieldNodes[0].directives\n      .find(d => d.name.value === 'role')\n      ?.arguments?.find(a => a.name.value === 'requires')\n      ?.value?.value;\n    \n    if (!context.user.roles.includes(requiredRole)) {\n      throw new ForbiddenError('Insufficient permissions');\n    }\n    return next();\n  }\n};\n```\n\n**Rate Limiting:**\n```typescript\nimport { shield, rule, and, or } from 'graphql-shield';\nimport { RateLimiterRedis } from 'rate-limiter-flexible';\n\nconst rateLimiter = new RateLimiterRedis({\n  storeClient: redisClient,\n  keyPrefix: 'graphql',\n  points: 100, // requests\n  duration: 60, // per 60 seconds\n});\n\nconst rateLimit = rule({ cache: 'contextual' })(\n  async (parent, args, context) => {\n    try {\n      await rateLimiter.consume(context.ip);\n      return true;\n    } catch {\n      return new Error('Rate limit exceeded');\n    }\n  }\n);\n```\n\nüìä MONITORING & ANALYTICS:\n\n**Apollo Studio Integration:**\n```typescript\nconst server = new ApolloServer({\n  plugins: [\n    ApolloServerPluginUsageReporting({\n      sendHeaders: { all: true },\n      sendVariableValues: { all: true }\n    }),\n    ApolloServerPluginSchemaReporting()\n  ]\n});\n```\n\n**Custom Metrics:**\n```typescript\nclass MetricsPlugin {\n  requestDidStart() {\n    return {\n      didResolveOperation(requestContext) {\n        metrics.increment('graphql.operation', {\n          operation: requestContext.request.operationName\n        });\n      },\n      \n      didEncounterErrors(requestContext) {\n        metrics.increment('graphql.errors', {\n          operation: requestContext.request.operationName\n        });\n      }\n    };\n  }\n}\n```\n\nüß™ TESTING STRATEGY:\n\n**Integration Tests:**\n```typescript\ndescribe('Property Queries', () => {\n  let server: ApolloServer;\n  \n  beforeAll(async () => {\n    server = createTestServer();\n  });\n  \n  it('should fetch properties with complex filtering', async () => {\n    const query = `\n      query GetProperties($filter: PropertyFilter!) {\n        properties(filter: $filter) {\n          nodes {\n            id\n            title\n            owner {\n              name\n            }\n            averageRating\n          }\n          pageInfo {\n            hasNextPage\n            hasPreviousPage\n          }\n        }\n      }\n    `;\n    \n    const { data } = await server.executeOperation({\n      query,\n      variables: {\n        filter: {\n          priceRange: { min: 100, max: 500 },\n          amenities: ['WIFI', 'PARKING'],\n          location: {\n            city: 'Barcelona',\n            radius: 10\n          }\n        }\n      }\n    });\n    \n    expect(data.properties.nodes).toHaveLength(5);\n    expect(data.properties.nodes[0].owner).toBeDefined();\n  });\n});\n```\n\nüìã DELIVERABLES:\n1. Complete GraphQL schema definition\n2. Resolver implementations con optimizaciones\n3. DataLoader setup para efficiency\n4. Authentication y authorization system\n5. Caching strategy con Redis\n6. Rate limiting y security measures\n7. Testing suite completa\n8. Performance monitoring setup\n9. API documentation con examples\n10. Deployment configuration\n\nIncluye best practices para schema design, resolver optimization, security, y monitoring en producci√≥n.",
      "tags": ["graphql", "apollo", "typescript", "performance", "caching"],
      "complexity": 9,
      "estimated_time": "70-90 hours",
      "use_cases": ["complex_api", "mobile_backend", "real_time_features"]
    },
    {
      "id": 6,
      "category": "development",
      "subcategory": "mobile",
      "difficulty": "expert",
      "title": "React Native Cross-Platform App",
      "prompt": "Como Senior Mobile Developer, desarrolla una aplicaci√≥n m√≥vil completa cross-platform para alquiler vacacional usando React Native con architecture patterns modernos y performance optimizations.\n\nüì± TECH STACK MODERNO:\n- React Native 0.72+ con New Architecture\n- TypeScript strict mode\n- Expo SDK 49+ con custom dev client\n- React Navigation 6 con typed navigation\n- React Query (TanStack Query) para state management\n- React Hook Form con validaciones\n- Reanimated 3 para animations\n- Async Storage para persistence\n- Flipper para debugging\n\nüèóÔ∏è PROJECT ARCHITECTURE:\n\n**Folder Structure:**\n```\nsrc/\n‚îú‚îÄ‚îÄ components/          # Reusable UI components\n‚îÇ   ‚îú‚îÄ‚îÄ atoms/          # Basic components\n‚îÇ   ‚îú‚îÄ‚îÄ molecules/      # Composed components\n‚îÇ   ‚îî‚îÄ‚îÄ organisms/      # Complex components\n‚îú‚îÄ‚îÄ screens/            # Screen components\n‚îú‚îÄ‚îÄ navigation/         # Navigation configuration\n‚îú‚îÄ‚îÄ hooks/             # Custom hooks\n‚îú‚îÄ‚îÄ services/          # API calls y external services\n‚îú‚îÄ‚îÄ stores/            # State management\n‚îú‚îÄ‚îÄ utils/             # Helper functions\n‚îú‚îÄ‚îÄ types/             # TypeScript definitions\n‚îî‚îÄ‚îÄ assets/            # Images, fonts, etc.\n```\n\n**Core Features Implementation:**\n\n1. **Authentication Flow:**\n```typescript\n// AuthContext.tsx\ninterface AuthContextType {\n  user: User | null;\n  login: (credentials: LoginCredentials) => Promise<void>;\n  logout: () => Promise<void>;\n  register: (data: RegisterData) => Promise<void>;\n  isLoading: boolean;\n}\n\nconst AuthContext = createContext<AuthContextType | undefined>(undefined);\n\nexport const AuthProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  const [user, setUser] = useState<User | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n  \n  useEffect(() => {\n    checkAuthState();\n  }, []);\n  \n  const checkAuthState = async () => {\n    try {\n      const token = await AsyncStorage.getItem('authToken');\n      if (token) {\n        const userData = await AuthService.validateToken(token);\n        setUser(userData);\n      }\n    } catch (error) {\n      await AsyncStorage.removeItem('authToken');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  \n  const login = async (credentials: LoginCredentials) => {\n    setIsLoading(true);\n    try {\n      const { user, token } = await AuthService.login(credentials);\n      await AsyncStorage.setItem('authToken', token);\n      setUser(user);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  \n  return (\n    <AuthContext.Provider value={{ user, login, logout, register, isLoading }}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n```\n\n2. **Property Search con Maps:**\n```typescript\n// PropertyMapScreen.tsx\nimport MapView, { Marker, Region } from 'react-native-maps';\nimport { useQuery } from '@tanstack/react-query';\n\nconst PropertyMapScreen: React.FC = () => {\n  const [region, setRegion] = useState<Region>({\n    latitude: 41.3851,\n    longitude: 2.1734,\n    latitudeDelta: 0.0922,\n    longitudeDelta: 0.0421,\n  });\n  \n  const { data: properties, isLoading } = useQuery({\n    queryKey: ['properties', region],\n    queryFn: () => PropertyService.searchByLocation(region),\n    enabled: !!region,\n  });\n  \n  const onRegionChangeComplete = useCallback((newRegion: Region) => {\n    setRegion(newRegion);\n  }, []);\n  \n  return (\n    <View style={styles.container}>\n      <MapView\n        style={styles.map}\n        region={region}\n        onRegionChangeComplete={onRegionChangeComplete}\n        showsUserLocation\n        showsMyLocationButton\n      >\n        {properties?.map((property) => (\n          <Marker\n            key={property.id}\n            coordinate={{\n              latitude: property.latitude,\n              longitude: property.longitude,\n            }}\n            onPress={() => navigateToProperty(property.id)}\n          >\n            <PropertyMarker property={property} />\n          </Marker>\n        ))}\n      </MapView>\n      \n      <SearchFilters onFiltersChange={handleFiltersChange} />\n      \n      {isLoading && <LoadingOverlay />}\n    </View>\n  );\n};\n```\n\n3. **Booking Flow con Animations:**\n```typescript\n// BookingFlow.tsx\nimport Animated, {\n  useSharedValue,\n  useAnimatedStyle,\n  withTiming,\n  runOnJS,\n} from 'react-native-reanimated';\n\nconst BookingFlow: React.FC = () => {\n  const [currentStep, setCurrentStep] = useState(0);\n  const translateX = useSharedValue(0);\n  \n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ translateX: translateX.value }],\n  }));\n  \n  const nextStep = useCallback(() => {\n    if (currentStep < steps.length - 1) {\n      translateX.value = withTiming(-width * (currentStep + 1), {}, (finished) => {\n        if (finished) {\n          runOnJS(setCurrentStep)(currentStep + 1);\n        }\n      });\n    }\n  }, [currentStep]);\n  \n  const steps = [\n    <DateSelection onNext={nextStep} />,\n    <GuestSelection onNext={nextStep} />,\n    <PaymentDetails onComplete={handleBookingComplete} />,\n  ];\n  \n  return (\n    <View style={styles.container}>\n      <ProgressIndicator currentStep={currentStep} totalSteps={steps.length} />\n      \n      <Animated.View style={[styles.stepsContainer, animatedStyle]}>\n        {steps.map((step, index) => (\n          <View key={index} style={styles.step}>\n            {step}\n          </View>\n        ))}\n      </Animated.View>\n    </View>\n  );\n};\n```\n\n4. **Offline Support:**\n```typescript\n// OfflineManager.ts\nimport NetInfo from '@react-native-async-storage/async-storage';\nimport { QueryClient } from '@tanstack/react-query';\n\nclass OfflineManager {\n  private queryClient: QueryClient;\n  private offlineQueue: OfflineAction[] = [];\n  \n  constructor(queryClient: QueryClient) {\n    this.queryClient = queryClient;\n    this.setupNetworkListener();\n  }\n  \n  private setupNetworkListener() {\n    NetInfo.addEventListener(state => {\n      if (state.isConnected) {\n        this.processOfflineQueue();\n      }\n    });\n  }\n  \n  async addToOfflineQueue(action: OfflineAction) {\n    this.offlineQueue.push(action);\n    await AsyncStorage.setItem('offlineQueue', JSON.stringify(this.offlineQueue));\n  }\n  \n  private async processOfflineQueue() {\n    while (this.offlineQueue.length > 0) {\n      const action = this.offlineQueue.shift();\n      try {\n        await this.executeAction(action);\n        this.queryClient.invalidateQueries({ queryKey: action.invalidateKey });\n      } catch (error) {\n        // Re-add to queue if failed\n        this.offlineQueue.unshift(action);\n        break;\n      }\n    }\n    \n    await AsyncStorage.setItem('offlineQueue', JSON.stringify(this.offlineQueue));\n  }\n}\n```\n\nüìä PERFORMANCE OPTIMIZATIONS:\n\n**Image Optimization:**\n```typescript\n// OptimizedImage.tsx\ninterface OptimizedImageProps {\n  uri: string;\n  width: number;\n  height: number;\n  placeholder?: string;\n}\n\nconst OptimizedImage: React.FC<OptimizedImageProps> = ({\n  uri,\n  width,\n  height,\n  placeholder\n}) => {\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState(false);\n  \n  const optimizedUri = useMemo(() => {\n    const pixelRatio = PixelRatio.get();\n    const actualWidth = width * pixelRatio;\n    const actualHeight = height * pixelRatio;\n    \n    return `${uri}?w=${actualWidth}&h=${actualHeight}&fit=crop&auto=format,compress`;\n  }, [uri, width, height]);\n  \n  return (\n    <View style={{ width, height }}>\n      {placeholder && isLoading && (\n        <Image\n          source={{ uri: placeholder }}\n          style={StyleSheet.absoluteFillObject}\n          blurRadius={2}\n        />\n      )}\n      \n      <Image\n        source={{ uri: optimizedUri }}\n        style={StyleSheet.absoluteFillObject}\n        onLoadStart={() => setIsLoading(true)}\n        onLoadEnd={() => setIsLoading(false)}\n        onError={() => setError(true)}\n        resizeMode=\"cover\"\n      />\n    </View>\n  );\n};\n```\n\n**List Performance:**\n```typescript\n// PropertyList.tsx\nconst PropertyList: React.FC = () => {\n  const renderItem = useCallback(({ item }: { item: Property }) => (\n    <PropertyCard key={item.id} property={item} />\n  ), []);\n  \n  const getItemLayout = useCallback(\n    (data: any, index: number) => ({\n      length: ITEM_HEIGHT,\n      offset: ITEM_HEIGHT * index,\n      index,\n    }),\n    []\n  );\n  \n  return (\n    <FlatList\n      data={properties}\n      renderItem={renderItem}\n      getItemLayout={getItemLayout}\n      keyExtractor={(item) => item.id}\n      removeClippedSubviews\n      maxToRenderPerBatch={10}\n      windowSize={10}\n      initialNumToRender={5}\n      onEndReachedThreshold={0.5}\n      onEndReached={loadMore}\n    />\n  );\n};\n```\n\nüîî PUSH NOTIFICATIONS:\n```typescript\n// NotificationService.ts\nimport messaging from '@react-native-firebase/messaging';\nimport notifee from '@notifee/react-native';\n\nclass NotificationService {\n  async initialize() {\n    await this.requestPermission();\n    await this.setupForegroundHandler();\n    await this.setupBackgroundHandler();\n    await this.getToken();\n  }\n  \n  private async requestPermission() {\n    const authStatus = await messaging().requestPermission();\n    return authStatus === messaging.AuthorizationStatus.AUTHORIZED ||\n           authStatus === messaging.AuthorizationStatus.PROVISIONAL;\n  }\n  \n  private async setupForegroundHandler() {\n    messaging().onMessage(async remoteMessage => {\n      await notifee.displayNotification({\n        title: remoteMessage.notification?.title,\n        body: remoteMessage.notification?.body,\n        android: {\n          channelId: 'default',\n          smallIcon: 'ic_notification',\n        },\n        ios: {\n          sound: 'default',\n        },\n      });\n    });\n  }\n}\n```\n\nüß™ TESTING STRATEGY:\n\n**Component Testing:**\n```typescript\n// PropertyCard.test.tsx\nimport { render, fireEvent } from '@testing-library/react-native';\nimport { PropertyCard } from '../PropertyCard';\n\ndescribe('PropertyCard', () => {\n  const mockProperty = {\n    id: '1',\n    title: 'Beautiful Apartment',\n    price: 120,\n    images: ['image1.jpg'],\n    rating: 4.5,\n  };\n  \n  it('should render property information correctly', () => {\n    const { getByText } = render(\n      <PropertyCard property={mockProperty} onPress={() => {}} />\n    );\n    \n    expect(getByText('Beautiful Apartment')).toBeTruthy();\n    expect(getByText('$120/night')).toBeTruthy();\n  });\n  \n  it('should call onPress when tapped', () => {\n    const onPressMock = jest.fn();\n    const { getByTestId } = render(\n      <PropertyCard property={mockProperty} onPress={onPressMock} />\n    );\n    \n    fireEvent.press(getByTestId('property-card'));\n    expect(onPressMock).toHaveBeenCalledWith(mockProperty.id);\n  });\n});\n```\n\nüìã DELIVERABLES:\n1. Complete React Native app con todas las features\n2. TypeScript definitions y type safety\n3. Navigation setup con deep linking\n4. State management con React Query\n5. Authentication flow completo\n6. Offline support implementation\n7. Push notifications setup\n8. Performance optimizations\n9. Testing suite completa\n10. Build y deployment configuration\n11. App Store y Play Store assets\n12. Documentation t√©cnica\n\nüöÄ BUILD & DEPLOYMENT:\n- EAS Build configuration\n- Fastlane automation\n- Code signing setup\n- Store submission guidelines\n- CI/CD con GitHub Actions\n- Beta testing con TestFlight/Internal Testing\n\nIncluye best practices para performance, security, accessibility y user experience en mobile.",
      "tags": ["react-native", "mobile", "typescript", "performance", "offline"],
      "complexity": 9,
      "estimated_time": "120-160 hours",
      "use_cases": ["mobile_app", "cross_platform", "marketplace"]
    },
    {
      "id": 7,
      "category": "devops",
      "subcategory": "kubernetes",
      "difficulty": "expert",
      "title": "Kubernetes Production Cluster",
      "prompt": "Como DevOps Engineer Senior y Kubernetes expert, dise√±a y despliega un cluster de Kubernetes production-ready para una plataforma de alquiler vacacional que maneje high availability, auto-scaling, security y observability.\n\nüèóÔ∏è CLUSTER ARCHITECTURE:\n\n**Infrastructure Overview:**\n- Multi-zone cluster (3 availability zones)\n- Control plane: 3 master nodes (HA)\n- Worker nodes: Auto-scaling groups (3-20 nodes)\n- Network: CNI con Calico\n- Storage: Persistent volumes con CSI drivers\n- Load balancer: NGINX Ingress Controller\n- Service mesh: Istio (optional)\n\n**Node Configuration:**\n```yaml\n# cluster-config.yaml\napiVersion: eksctl.io/v1alpha5\nkind: ClusterConfig\n\nmetadata:\n  name: vacation-rental-prod\n  region: us-west-2\n  version: \"1.27\"\n\niam:\n  withOIDC: true\n  serviceAccounts:\n  - metadata:\n      name: aws-load-balancer-controller\n      namespace: kube-system\n    wellKnownPolicies:\n      awsLoadBalancerController: true\n\nnodeGroups:\n- name: system-nodes\n  instanceType: t3.medium\n  minSize: 3\n  maxSize: 6\n  desiredCapacity: 3\n  availabilityZones: [\"us-west-2a\", \"us-west-2b\", \"us-west-2c\"]\n  labels:\n    role: system\n  taints:\n  - key: system\n    value: \"true\"\n    effect: NoSchedule\n    \n- name: application-nodes\n  instanceType: t3.large\n  minSize: 3\n  maxSize: 20\n  desiredCapacity: 5\n  availabilityZones: [\"us-west-2a\", \"us-west-2b\", \"us-west-2c\"]\n  labels:\n    role: application\n  ssh:\n    enableSsm: true\n```\n\nüì¶ APPLICATION DEPLOYMENTS:\n\n**Backend API Deployment:**\n```yaml\n# api-deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: api-server\n  namespace: vacation-rental\n  labels:\n    app: api-server\n    version: v1.0.0\nspec:\n  replicas: 3\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxSurge: 1\n      maxUnavailable: 0\n  selector:\n    matchLabels:\n      app: api-server\n  template:\n    metadata:\n      labels:\n        app: api-server\n        version: v1.0.0\n      annotations:\n        prometheus.io/scrape: \"true\"\n        prometheus.io/port: \"3000\"\n        prometheus.io/path: \"/metrics\"\n    spec:\n      serviceAccountName: api-server-sa\n      securityContext:\n        runAsNonRoot: true\n        runAsUser: 10001\n        fsGroup: 10001\n      containers:\n      - name: api-server\n        image: vacation-rental/api:v1.0.0\n        ports:\n        - containerPort: 3000\n          name: http\n        env:\n        - name: NODE_ENV\n          value: \"production\"\n        - name: DATABASE_URL\n          valueFrom:\n            secretKeyRef:\n              name: database-secret\n              key: url\n        - name: REDIS_URL\n          valueFrom:\n            secretKeyRef:\n              name: redis-secret\n              key: url\n        resources:\n          requests:\n            memory: \"256Mi\"\n            cpu: \"250m\"\n          limits:\n            memory: \"512Mi\"\n            cpu: \"500m\"\n        livenessProbe:\n          httpGet:\n            path: /health\n            port: 3000\n          initialDelaySeconds: 30\n          periodSeconds: 10\n          timeoutSeconds: 5\n          failureThreshold: 3\n        readinessProbe:\n          httpGet:\n            path: /ready\n            port: 3000\n          initialDelaySeconds: 5\n          periodSeconds: 5\n          timeoutSeconds: 3\n          failureThreshold: 2\n        volumeMounts:\n        - name: app-config\n          mountPath: /app/config\n          readOnly: true\n        - name: temp-storage\n          mountPath: /tmp\n      volumes:\n      - name: app-config\n        configMap:\n          name: api-config\n      - name: temp-storage\n        emptyDir: {}\n      tolerations:\n      - effect: NoSchedule\n        key: system\n        operator: Equal\n        value: \"true\"\n      affinity:\n        podAntiAffinity:\n          preferredDuringSchedulingIgnoredDuringExecution:\n          - weight: 100\n            podAffinityTerm:\n              labelSelector:\n                matchExpressions:\n                - key: app\n                  operator: In\n                  values:\n                  - api-server\n              topologyKey: kubernetes.io/hostname\n```\n\n**HPA Configuration:**\n```yaml\n# api-hpa.yaml\napiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: api-server-hpa\n  namespace: vacation-rental\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: api-server\n  minReplicas: 3\n  maxReplicas: 20\n  metrics:\n  - type: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 70\n  - type: Resource\n    resource:\n      name: memory\n      target:\n        type: Utilization\n        averageUtilization: 80\n  - type: Pods\n    pods:\n      metric:\n        name: http_requests_per_second\n      target:\n        type: AverageValue\n        averageValue: \"30\"\n  behavior:\n    scaleDown:\n      stabilizationWindowSeconds: 300\n      policies:\n      - type: Percent\n        value: 10\n        periodSeconds: 60\n    scaleUp:\n      stabilizationWindowSeconds: 0\n      policies:\n      - type: Percent\n        value: 100\n        periodSeconds: 15\n      - type: Pods\n        value: 4\n        periodSeconds: 15\n      selectPolicy: Max\n```\n\nüîí SECURITY IMPLEMENTATION:\n\n**Network Policies:**\n```yaml\n# network-policy.yaml\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: api-server-netpol\n  namespace: vacation-rental\nspec:\n  podSelector:\n    matchLabels:\n      app: api-server\n  policyTypes:\n  - Ingress\n  - Egress\n  ingress:\n  - from:\n    - namespaceSelector:\n        matchLabels:\n          name: ingress-nginx\n    - podSelector:\n        matchLabels:\n          app: frontend\n    ports:\n    - protocol: TCP\n      port: 3000\n  egress:\n  - to:\n    - podSelector:\n        matchLabels:\n          app: database\n    ports:\n    - protocol: TCP\n      port: 5432\n  - to:\n    - podSelector:\n        matchLabels:\n          app: redis\n    ports:\n    - protocol: TCP\n      port: 6379\n  - to: []\n    ports:\n    - protocol: TCP\n      port: 443\n    - protocol: TCP\n      port: 53\n    - protocol: UDP\n      port: 53\n```\n\n**Pod Security Standards:**\n```yaml\n# pod-security-policy.yaml\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: vacation-rental\n  labels:\n    pod-security.kubernetes.io/enforce: restricted\n    pod-security.kubernetes.io/audit: restricted\n    pod-security.kubernetes.io/warn: restricted\n```\n\n**RBAC Configuration:**\n```yaml\n# rbac.yaml\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: api-server-sa\n  namespace: vacation-rental\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: api-server-role\n  namespace: vacation-rental\nrules:\n- apiGroups: [\"\"]\n  resources: [\"configmaps\", \"secrets\"]\n  verbs: [\"get\", \"list\"]\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: api-server-binding\n  namespace: vacation-rental\nsubjects:\n- kind: ServiceAccount\n  name: api-server-sa\n  namespace: vacation-rental\nroleRef:\n  kind: Role\n  name: api-server-role\n  apiGroup: rbac.authorization.k8s.io\n```\n\nüìä MONITORING & OBSERVABILITY:\n\n**Prometheus Stack:**\n```yaml\n# prometheus-values.yaml\nprometheus:\n  prometheusSpec:\n    retention: 30d\n    storageSpec:\n      volumeClaimTemplate:\n        spec:\n          storageClassName: gp3\n          accessModes: [\"ReadWriteOnce\"]\n          resources:\n            requests:\n              storage: 100Gi\n    additionalScrapeConfigs:\n    - job_name: 'vacation-rental'\n      kubernetes_sd_configs:\n      - role: pod\n        namespaces:\n          names:\n          - vacation-rental\n      relabel_configs:\n      - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]\n        action: keep\n        regex: true\n        \ngrafana:\n  adminPassword: \"secure-password\"\n  persistence:\n    enabled: true\n    size: 10Gi\n  dashboardProviders:\n    dashboardproviders.yaml:\n      apiVersion: 1\n      providers:\n      - name: 'vacation-rental'\n        orgId: 1\n        folder: 'Vacation Rental'\n        type: file\n        disableDeletion: false\n        editable: true\n        options:\n          path: /var/lib/grafana/dashboards/vacation-rental\n```\n\n**Jaeger Tracing:**\n```yaml\n# jaeger.yaml\napiVersion: jaegertracing.io/v1\nkind: Jaeger\nmetadata:\n  name: jaeger\n  namespace: observability\nspec:\n  strategy: production\n  storage:\n    type: elasticsearch\n    elasticsearch:\n      nodeCount: 3\n      storage:\n        storageClassName: gp3\n        size: 50Gi\n  ingress:\n    enabled: true\n    annotations:\n      kubernetes.io/ingress.class: nginx\n      cert-manager.io/cluster-issuer: letsencrypt-prod\n    hosts:\n    - jaeger.vacation-rental.com\n    tls:\n    - secretName: jaeger-tls\n      hosts:\n      - jaeger.vacation-rental.com\n```\n\nüîÑ CI/CD PIPELINE:\n\n**GitOps con ArgoCD:**\n```yaml\n# argocd-application.yaml\napiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: vacation-rental-api\n  namespace: argocd\nspec:\n  project: default\n  source:\n    repoURL: https://github.com/company/vacation-rental-k8s\n    targetRevision: HEAD\n    path: overlays/production\n  destination:\n    server: https://kubernetes.default.svc\n    namespace: vacation-rental\n  syncPolicy:\n    automated:\n      prune: true\n      selfHeal: true\n      allowEmpty: false\n    syncOptions:\n    - CreateNamespace=true\n    - PrunePropagationPolicy=foreground\n    retry:\n      limit: 5\n      backoff:\n        duration: 5s\n        factor: 2\n        maxDuration: 3m\n```\n\n**GitHub Actions Workflow:**\n```yaml\n# .github/workflows/deploy.yml\nname: Deploy to Kubernetes\non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - uses: actions/setup-node@v3\n      with:\n        node-version: '18'\n        cache: 'npm'\n    - run: npm ci\n    - run: npm run test\n    - run: npm run lint\n    \n  build:\n    needs: test\n    runs-on: ubuntu-latest\n    if: github.ref == 'refs/heads/main'\n    steps:\n    - uses: actions/checkout@v3\n    - name: Configure AWS credentials\n      uses: aws-actions/configure-aws-credentials@v2\n      with:\n        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}\n        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}\n        aws-region: us-west-2\n        \n    - name: Login to Amazon ECR\n      uses: aws-actions/amazon-ecr-login@v1\n      \n    - name: Build and push Docker image\n      run: |\n        IMAGE_TAG=${{ github.sha }}\n        docker build -t vacation-rental/api:$IMAGE_TAG .\n        docker tag vacation-rental/api:$IMAGE_TAG $ECR_REGISTRY/vacation-rental/api:$IMAGE_TAG\n        docker push $ECR_REGISTRY/vacation-rental/api:$IMAGE_TAG\n        \n    - name: Update Kustomization\n      run: |\n        cd k8s/overlays/production\n        kustomize edit set image vacation-rental/api=$ECR_REGISTRY/vacation-rental/api:${{ github.sha }}\n        git config --global user.email \"ci@company.com\"\n        git config --global user.name \"CI Bot\"\n        git add -A\n        git commit -m \"Update image tag to ${{ github.sha }}\"\n        git push\n```\n\nüíæ BACKUP & DISASTER RECOVERY:\n\n**Velero Backup:**\n```yaml\n# velero-backup.yaml\napiVersion: velero.io/v1\nkind: Schedule\nmetadata:\n  name: daily-backup\n  namespace: velero\nspec:\n  schedule: \"0 2 * * *\"\n  template:\n    includedNamespaces:\n    - vacation-rental\n    - monitoring\n    excludedResources:\n    - events\n    - events.events.k8s.io\n    storageLocation: default\n    volumeSnapshotLocations:\n    - default\n    ttl: 720h0m0s\n```\n\nüìã DELIVERABLES:\n1. Complete cluster configuration (eksctl/terraform)\n2. Application manifests con best practices\n3. Security policies y RBAC setup\n4. Monitoring stack (Prometheus/Grafana/Jaeger)\n5. CI/CD pipeline con GitOps\n6. Backup y disaster recovery plan\n7. Auto-scaling configuration\n8. Network policies y service mesh\n9. Secrets management setup\n10. Documentation y runbooks\n11. Incident response procedures\n12. Performance tuning guide\n\nüõ†Ô∏è OPERATIONAL PROCEDURES:\n- Cluster upgrades strategy\n- Node maintenance procedures\n- Application rollback process\n- Capacity planning guidelines\n- Cost optimization recommendations\n- Security audit checklist\n\nIncluye scripts de automation, monitoring dashboards, alerting rules y documentaci√≥n completa para operations.",
      "tags": ["kubernetes", "devops", "monitoring", "security", "automation"],
      "complexity": 10,
      "estimated_time": "80-120 hours",
      "use_cases": ["production_cluster", "microservices", "high_availability"]
    },
    {
      "id": 8,
      "category": "ai",
      "subcategory": "llm",
      "difficulty": "expert",
      "title": "Advanced LLM Integration System",
      "prompt": "Como AI Engineer especializado en Large Language Models, desarrolla un sistema completo de integraci√≥n con m√∫ltiples LLMs para una plataforma de alquiler vacacional que incluya prompt engineering, fine-tuning, retrieval-augmented generation (RAG), y optimizaci√≥n de costos.\n\nüß† SYSTEM ARCHITECTURE:\n\n**Multi-LLM Provider Setup:**\n```typescript\n// llm-providers.ts\nimport { OpenAI } from 'openai';\nimport { Anthropic } from '@anthropic-ai/sdk';\nimport { GoogleGenerativeAI } from '@google/generative-ai';\n\ninterface LLMProvider {\n  name: string;\n  model: string;\n  costPerToken: number;\n  maxTokens: number;\n  capabilities: string[];\n  generate(prompt: string, options?: any): Promise<string>;\n}\n\nclass OpenAIProvider implements LLMProvider {\n  name = 'openai';\n  model = 'gpt-4-turbo';\n  costPerToken = 0.00003;\n  maxTokens = 128000;\n  capabilities = ['text', 'code', 'analysis', 'creativity'];\n  \n  private client: OpenAI;\n  \n  constructor(apiKey: string) {\n    this.client = new OpenAI({ apiKey });\n  }\n  \n  async generate(prompt: string, options: any = {}) {\n    const response = await this.client.chat.completions.create({\n      model: this.model,\n      messages: [{ role: 'user', content: prompt }],\n      temperature: options.temperature || 0.7,\n      max_tokens: options.maxTokens || 2000,\n      top_p: options.topP || 0.9,\n      frequency_penalty: options.frequencyPenalty || 0,\n      presence_penalty: options.presencePenalty || 0,\n    });\n    \n    return response.choices[0].message.content || '';\n  }\n}\n\nclass ClaudeProvider implements LLMProvider {\n  name = 'claude';\n  model = 'claude-3-opus';\n  costPerToken = 0.000015;\n  maxTokens = 200000;\n  capabilities = ['text', 'analysis', 'reasoning', 'code'];\n  \n  private client: Anthropic;\n  \n  constructor(apiKey: string) {\n    this.client = new Anthropic({ apiKey });\n  }\n  \n  async generate(prompt: string, options: any = {}) {\n    const response = await this.client.messages.create({\n      model: this.model,\n      max_tokens: options.maxTokens || 2000,\n      temperature: options.temperature || 0.7,\n      messages: [{ role: 'user', content: prompt }],\n    });\n    \n    return response.content[0].type === 'text' ? response.content[0].text : '';\n  }\n}\n\nclass LLMOrchestrator {\n  private providers = new Map<string, LLMProvider>();\n  private routingRules: RoutingRule[];\n  private costTracker: CostTracker;\n  \n  constructor() {\n    this.costTracker = new CostTracker();\n    this.setupRoutingRules();\n  }\n  \n  addProvider(provider: LLMProvider) {\n    this.providers.set(provider.name, provider);\n  }\n  \n  async generate(task: AITask): Promise<AIResponse> {\n    const selectedProvider = this.selectProvider(task);\n    const optimizedPrompt = await this.optimizePrompt(task.prompt, selectedProvider);\n    \n    const startTime = Date.now();\n    const response = await selectedProvider.generate(optimizedPrompt, task.options);\n    const endTime = Date.now();\n    \n    await this.costTracker.logUsage({\n      provider: selectedProvider.name,\n      model: selectedProvider.model,\n      inputTokens: this.countTokens(optimizedPrompt),\n      outputTokens: this.countTokens(response),\n      latency: endTime - startTime,\n      cost: this.calculateCost(selectedProvider, optimizedPrompt, response),\n    });\n    \n    return {\n      content: response,\n      provider: selectedProvider.name,\n      model: selectedProvider.model,\n      metadata: {\n        latency: endTime - startTime,\n        confidence: await this.calculateConfidence(response),\n        cost: this.calculateCost(selectedProvider, optimizedPrompt, response),\n      },\n    };\n  }\n  \n  private selectProvider(task: AITask): LLMProvider {\n    // Smart routing based on task type, cost, and performance\n    for (const rule of this.routingRules) {\n      if (rule.matches(task)) {\n        const provider = this.providers.get(rule.providerName);\n        if (provider) return provider;\n      }\n    }\n    \n    // Fallback to default provider\n    return this.providers.get('openai')!;\n  }\n}\n```\n\n**RAG Implementation:**\n```typescript\n// rag-system.ts\nimport { ChromaClient } from 'chromadb';\nimport { RecursiveCharacterTextSplitter } from 'langchain/text_splitter';\nimport { OpenAIEmbeddings } from 'langchain/embeddings/openai';\n\nclass RAGSystem {\n  private vectorStore: ChromaClient;\n  private embeddings: OpenAIEmbeddings;\n  private textSplitter: RecursiveCharacterTextSplitter;\n  \n  constructor() {\n    this.vectorStore = new ChromaClient();\n    this.embeddings = new OpenAIEmbeddings({\n      openAIApiKey: process.env.OPENAI_API_KEY,\n      modelName: 'text-embedding-3-large',\n    });\n    \n    this.textSplitter = new RecursiveCharacterTextSplitter({\n      chunkSize: 1000,\n      chunkOverlap: 200,\n      separators: ['\\n\\n', '\\n', ' ', ''],\n    });\n  }\n  \n  async ingestDocuments(documents: Document[]) {\n    const collection = await this.vectorStore.getOrCreateCollection({\n      name: 'vacation_rental_knowledge',\n      metadata: { 'hnsw:space': 'cosine' },\n    });\n    \n    for (const doc of documents) {\n      const chunks = await this.textSplitter.splitText(doc.content);\n      \n      for (let i = 0; i < chunks.length; i++) {\n        const embedding = await this.embeddings.embedQuery(chunks[i]);\n        \n        await collection.add({\n          ids: [`${doc.id}_chunk_${i}`],\n          embeddings: [embedding],\n          metadatas: [{\n            source: doc.source,\n            title: doc.title,\n            chunk_index: i,\n            document_id: doc.id,\n            timestamp: new Date().toISOString(),\n          }],\n          documents: [chunks[i]],\n        });\n      }\n    }\n  }\n  \n  async retrieveRelevantContext(\n    query: string,\n    options: {\n      topK?: number;\n      threshold?: number;\n      filters?: Record<string, any>;\n    } = {}\n  ): Promise<RetrievalResult[]> {\n    const { topK = 5, threshold = 0.7, filters } = options;\n    \n    const queryEmbedding = await this.embeddings.embedQuery(query);\n    \n    const collection = await this.vectorStore.getCollection({ name: 'vacation_rental_knowledge' });\n    \n    const results = await collection.query({\n      queryEmbeddings: [queryEmbedding],\n      nResults: topK,\n      where: filters,\n    });\n    \n    return results.documents[0]\n      .map((doc, index) => ({\n        content: doc,\n        score: results.distances![0][index],\n        metadata: results.metadatas![0][index],\n      }))\n      .filter(result => result.score >= threshold);\n  }\n  \n  async generateWithRAG(\n    query: string,\n    systemPrompt: string,\n    llmProvider: LLMProvider\n  ): Promise<string> {\n    // Retrieve relevant context\n    const context = await this.retrieveRelevantContext(query, { topK: 3 });\n    \n    // Construct enhanced prompt with context\n    const contextText = context\n      .map(item => `Source: ${item.metadata.source}\\n${item.content}`)\n      .join('\\n\\n---\\n\\n');\n    \n    const enhancedPrompt = `\n${systemPrompt}\n\nRelevant Context:\n${contextText}\n\nUser Query: ${query}\n\nPlease provide a helpful response based on the context provided. If the context doesn't contain relevant information, clearly state that and provide general guidance.\n`;\n    \n    return await llmProvider.generate(enhancedPrompt);\n  }\n}\n```\n\n**Prompt Engineering Framework:**\n```typescript\n// prompt-engineering.ts\ninterface PromptTemplate {\n  id: string;\n  name: string;\n  category: string;\n  template: string;\n  variables: string[];\n  examples: PromptExample[];\n  metadata: {\n    effectiveness: number;\n    avgLatency: number;\n    avgCost: number;\n    lastUpdated: Date;\n  };\n}\n\nclass PromptOptimizer {\n  private templates = new Map<string, PromptTemplate>();\n  private performanceMetrics = new Map<string, PerformanceMetric[]>();\n  \n  async optimizePrompt(\n    basePrompt: string,\n    task: AITask,\n    provider: LLMProvider\n  ): Promise<string> {\n    // Apply prompt engineering techniques\n    let optimizedPrompt = basePrompt;\n    \n    // Add role-based instructions\n    if (task.category === 'customer_service') {\n      optimizedPrompt = this.addCustomerServiceRole(optimizedPrompt);\n    } else if (task.category === 'property_description') {\n      optimizedPrompt = this.addPropertyExpertRole(optimizedPrompt);\n    }\n    \n    // Add few-shot examples\n    const examples = await this.getFewShotExamples(task.category);\n    if (examples.length > 0) {\n      optimizedPrompt = this.addFewShotExamples(optimizedPrompt, examples);\n    }\n    \n    // Add chain-of-thought prompting for complex tasks\n    if (task.complexity === 'high') {\n      optimizedPrompt = this.addChainOfThought(optimizedPrompt);\n    }\n    \n    // Provider-specific optimizations\n    optimizedPrompt = this.applyProviderOptimizations(optimizedPrompt, provider);\n    \n    return optimizedPrompt;\n  }\n  \n  private addCustomerServiceRole(prompt: string): string {\n    return `You are Sandra, an expert customer service representative for a vacation rental platform. You have extensive knowledge about properties, booking processes, policies, and local attractions. You are helpful, professional, and always strive to provide accurate information while maintaining a warm, welcoming tone.\n\n${prompt}`;\n  }\n  \n  private addPropertyExpertRole(prompt: string): string {\n    return `You are a professional property marketing expert specializing in vacation rentals. You excel at creating compelling, accurate property descriptions that highlight unique features, amenities, and location benefits. Your descriptions are engaging, informative, and help potential guests envision their perfect stay.\n\n${prompt}`;\n  }\n  \n  private addChainOfThought(prompt: string): string {\n    return `${prompt}\n\nPlease think through this step by step:\n1. First, analyze the key aspects of the request\n2. Consider any relevant policies or constraints\n3. Identify the best approach to help the user\n4. Provide your final response with clear reasoning`;\n  }\n  \n  async evaluatePromptPerformance(\n    promptId: string,\n    responses: AIResponse[],\n    humanEvaluations: HumanEvaluation[]\n  ): Promise<PromptPerformanceReport> {\n    const metrics = {\n      accuracy: this.calculateAccuracy(responses, humanEvaluations),\n      relevance: this.calculateRelevance(responses, humanEvaluations),\n      coherence: this.calculateCoherence(responses),\n      avgLatency: this.calculateAverageLatency(responses),\n      avgCost: this.calculateAverageCost(responses),\n      userSatisfaction: this.calculateUserSatisfaction(humanEvaluations),\n    };\n    \n    return {\n      promptId,\n      metrics,\n      recommendations: await this.generateOptimizationRecommendations(metrics),\n      timestamp: new Date(),\n    };\n  }\n}\n```\n\n**Fine-tuning Pipeline:**\n```typescript\n// fine-tuning.ts\nclass FineTuningPipeline {\n  private dataProcessor: DataProcessor;\n  private modelTrainer: ModelTrainer;\n  private evaluator: ModelEvaluator;\n  \n  async createTrainingDataset(\n    conversations: Conversation[],\n    category: string\n  ): Promise<TrainingDataset> {\n    const processedData = await Promise.all(\n      conversations.map(async (conv) => {\n        // Clean and format conversation data\n        const cleaned = await this.dataProcessor.cleanConversation(conv);\n        \n        // Create training examples\n        return {\n          messages: [\n            {\n              role: 'system',\n              content: this.getSystemPromptForCategory(category),\n            },\n            {\n              role: 'user',\n              content: cleaned.userMessage,\n            },\n            {\n              role: 'assistant',\n              content: cleaned.assistantResponse,\n            },\n          ],\n          metadata: {\n            category,\n            quality_score: cleaned.qualityScore,\n            timestamp: conv.timestamp,\n          },\n        };\n      })\n    );\n    \n    // Filter high-quality examples\n    const filteredData = processedData.filter(\n      (example) => example.metadata.quality_score > 0.8\n    );\n    \n    // Split into train/validation sets\n    const shuffled = this.shuffleArray(filteredData);\n    const splitIndex = Math.floor(shuffled.length * 0.8);\n    \n    return {\n      training: shuffled.slice(0, splitIndex),\n      validation: shuffled.slice(splitIndex),\n      metadata: {\n        totalExamples: filteredData.length,\n        category,\n        created: new Date(),\n      },\n    };\n  }\n  \n  async startFineTuning(\n    dataset: TrainingDataset,\n    config: FineTuningConfig\n  ): Promise<FineTuningJob> {\n    // Upload training data\n    const trainingFile = await this.uploadTrainingFile(dataset.training);\n    const validationFile = await this.uploadTrainingFile(dataset.validation);\n    \n    // Start fine-tuning job\n    const job = await this.modelTrainer.createFineTuningJob({\n      training_file: trainingFile.id,\n      validation_file: validationFile.id,\n      model: config.baseModel,\n      hyperparameters: {\n        n_epochs: config.epochs || 3,\n        batch_size: config.batchSize || 1,\n        learning_rate_multiplier: config.learningRate || 0.1,\n      },\n      suffix: config.modelSuffix,\n    });\n    \n    return {\n      id: job.id,\n      status: job.status,\n      config,\n      dataset: dataset.metadata,\n      createdAt: new Date(),\n    };\n  }\n  \n  async evaluateFineTunedModel(\n    modelId: string,\n    testDataset: TestDataset\n  ): Promise<ModelEvaluationReport> {\n    const results = await Promise.all(\n      testDataset.examples.map(async (example) => {\n        const prediction = await this.generateWithModel(modelId, example.input);\n        const scores = await this.evaluator.scoreResponse(\n          prediction,\n          example.expectedOutput\n        );\n        \n        return {\n          input: example.input,\n          expected: example.expectedOutput,\n          predicted: prediction,\n          scores,\n        };\n      })\n    );\n    \n    return {\n      modelId,\n      overallScores: this.aggregateScores(results),\n      detailedResults: results,\n      recommendations: this.generateModelRecommendations(results),\n      evaluatedAt: new Date(),\n    };\n  }\n}\n```\n\n**Cost Optimization System:**\n```typescript\n// cost-optimizer.ts\nclass CostOptimizer {\n  private usageAnalyzer: UsageAnalyzer;\n  private cachingLayer: CachingLayer;\n  private requestRouter: RequestRouter;\n  \n  async optimizeRequest(request: AIRequest): Promise<OptimizedRequest> {\n    // Check cache first\n    const cachedResponse = await this.cachingLayer.get(request.prompt);\n    if (cachedResponse && this.isCacheValid(cachedResponse)) {\n      return {\n        ...request,\n        useCached: true,\n        estimatedCost: 0,\n      };\n    }\n    \n    // Analyze request complexity\n    const complexity = await this.analyzeComplexity(request);\n    \n    // Select optimal provider based on cost and capability\n    const recommendations = await this.getProviderRecommendations(\n      request,\n      complexity\n    );\n    \n    // Apply prompt compression if beneficial\n    let optimizedPrompt = request.prompt;\n    if (recommendations.shouldCompress) {\n      optimizedPrompt = await this.compressPrompt(request.prompt);\n    }\n    \n    return {\n      ...request,\n      prompt: optimizedPrompt,\n      recommendedProvider: recommendations.bestProvider,\n      estimatedCost: recommendations.estimatedCost,\n      optimizations: recommendations.appliedOptimizations,\n    };\n  }\n  \n  async getProviderRecommendations(\n    request: AIRequest,\n    complexity: ComplexityAnalysis\n  ): Promise<ProviderRecommendations> {\n    const providers = await this.getAvailableProviders();\n    const scores = new Map<string, ProviderScore>();\n    \n    for (const provider of providers) {\n      const cost = this.estimateCost(request, provider);\n      const capability = this.assessCapability(request, provider, complexity);\n      const performance = await this.getPerformanceMetrics(provider);\n      \n      const score = this.calculateProviderScore({\n        cost,\n        capability,\n        performance,\n        weights: {\n          cost: 0.4,\n          capability: 0.4,\n          performance: 0.2,\n        },\n      });\n      \n      scores.set(provider.name, score);\n    }\n    \n    const bestProvider = this.selectBestProvider(scores);\n    \n    return {\n      bestProvider: bestProvider.name,\n      estimatedCost: bestProvider.estimatedCost,\n      alternatives: this.getAlternatives(scores, 3),\n      shouldCompress: bestProvider.estimatedCost > 0.01,\n      appliedOptimizations: this.getAppliedOptimizations(bestProvider),\n    };\n  }\n  \n  async generateCostReport(timeframe: Timeframe): Promise<CostReport> {\n    const usage = await this.usageAnalyzer.getUsageData(timeframe);\n    \n    return {\n      totalCost: usage.totalCost,\n      breakdown: {\n        byProvider: usage.byProvider,\n        byModel: usage.byModel,\n        byCategory: usage.byCategory,\n      },\n      trends: await this.analyzeCostTrends(usage),\n      optimizationOpportunities: await this.identifyOptimizations(usage),\n      projectedMonthlyCost: this.projectMonthlyCost(usage),\n      recommendations: await this.generateCostRecommendations(usage),\n    };\n  }\n}\n```\n\nüìä MONITORING & ANALYTICS:\n\n**Performance Tracking:**\n```typescript\n// analytics.ts\nclass AIAnalytics {\n  private metrics: MetricsCollector;\n  private dashboard: DashboardBuilder;\n  \n  async trackRequest(request: AIRequest, response: AIResponse) {\n    await this.metrics.record({\n      timestamp: new Date(),\n      provider: response.provider,\n      model: response.model,\n      category: request.category,\n      latency: response.metadata.latency,\n      cost: response.metadata.cost,\n      inputTokens: this.countTokens(request.prompt),\n      outputTokens: this.countTokens(response.content),\n      userSatisfaction: await this.getUserFeedback(request.id),\n      cacheHit: request.useCached || false,\n    });\n  }\n  \n  async generatePerformanceReport(): Promise<PerformanceReport> {\n    const data = await this.metrics.getAggregatedData();\n    \n    return {\n      overview: {\n        totalRequests: data.totalRequests,\n        averageLatency: data.averageLatency,\n        totalCost: data.totalCost,\n        userSatisfactionScore: data.averageUserSatisfaction,\n      },\n      trends: {\n        latencyTrend: data.latencyTrend,\n        costTrend: data.costTrend,\n        volumeTrend: data.volumeTrend,\n      },\n      providerComparison: data.providerMetrics,\n      recommendations: await this.generateRecommendations(data),\n    };\n  }\n}\n```\n\nüìã DELIVERABLES:\n1. Multi-LLM provider orchestration system\n2. RAG implementation con vector store\n3. Prompt engineering framework\n4. Fine-tuning pipeline completo\n5. Cost optimization algorithms\n6. Performance monitoring dashboard\n7. A/B testing framework para prompts\n8. Caching layer para cost reduction\n9. Evaluation metrics y benchmarks\n10. Documentation t√©cnica completa\n11. API integration examples\n12. Security y compliance guidelines\n\nüéØ USE CASES ESPEC√çFICOS:\n- Customer service automation\n- Property description generation\n- Review analysis y sentiment\n- Pricing optimization suggestions\n- Content moderation\n- Multi-language support\n- Personalization engine\n- Market analysis y insights\n\nIncluye c√≥digo production-ready, best practices para LLM integration, cost optimization strategies y comprehensive testing suite.",
      "tags": ["llm", "ai", "rag", "prompt-engineering", "fine-tuning", "cost-optimization"],
      "complexity": 10,
      "estimated_time": "100-140 hours",
      "use_cases": ["ai_platform", "chatbot", "content_generation", "analysis"]
    }
  ]
}